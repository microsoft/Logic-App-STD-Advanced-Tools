using Azure.Data.Tables;
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.WindowsAzure.ResourceStack.Common.Extensions;
using Azure.Data.Tables.Models;
using Azure;
using McMaster.Extensions.CommandLineUtils;
using LogicAppAdvancedTool.Shared;

namespace LogicAppAdvancedTool.Operations
{
    public static class MergeRunHistory
    {
        public static void Run(string sourceWorkflow, string targetWorkflow, int startTime, int endTime)
        {
            CommonOperations.AlertExperimentalFeature();

            if (String.IsNullOrEmpty(targetWorkflow))
            {
                string autoGeneratedWorkflowName = $"AutoGenerated_RunHistory_{DateTime.Now.ToString("yyyyMMddHHmmss")}";
                string autoGeneratedWorkflowPath = $"{AppSettings.RootFolder}\\{autoGeneratedWorkflowName}";
                string autoGeneratedWorkflowDefinition = CommonOperations.GetEmbeddedResource("LogicAppAdvancedTool.Resources.EmptyDefinition.json");

                Console.WriteLine($"Target workflow name not provided, creating new workflow for merging run history named {autoGeneratedWorkflowName}");

                CommonOperations.CreateWorkflow(autoGeneratedWorkflowPath, autoGeneratedWorkflowName, autoGeneratedWorkflowDefinition);

                Console.WriteLine($"New workflow created named {autoGeneratedWorkflowName}");

                targetWorkflow = autoGeneratedWorkflowName;
            }

            List<TableEntity> targetWorkflows = TableOperations.QueryCurrentWorkflowByName(targetWorkflow);

            if (targetWorkflows.Count == 0)
            {
                throw new UserInputException($"Cannot find existing workflow with name {targetWorkflow}, please review your input.");
            }

            Console.WriteLine($"Existing workflow named {targetWorkflow} found.");
            string targetFlowID = targetWorkflows.FirstOrDefault().GetString("FlowId");

            string sourceFlowID = WorkflowSelector.SelectFlowIDByName(sourceWorkflow);

            if (sourceFlowID == targetFlowID)
            {
                throw new UserInputException("source workflow id and target workflow id is the same, please select different workflows");
            }

            Console.WriteLine($"""
                Merge information:
                1. Source workflow name: {sourceWorkflow}, source flow id: {sourceFlowID}, target workflow name: {targetWorkflow} target flow id: {targetFlowID}, start date: {startTime}, end date: {endTime}.
                2. For the tables which contain huge mounts of records (eg: actions/variables), it will take a while for merging.
                3. Make sure before you run the command, Logic App doesn't experience high CPU or memory issue. 
                4. Merging process will consume ~120 MB memory and 10% CPU (CPU usage is based on WS1 ASP).
                5. IMPORTENT!!! This operation cannot be reverted!!!
                """);

            CommonOperations.PromptConfirmation("Please review above information and input for confirmation to merge run history");

            //We need to create new records and change workflow id to existing one in main table
            OverwriteFlowId(sourceFlowID, targetFlowID, targetWorkflow);

            string workflowPrefix = CommonOperations.GenerateLogicAppPrefix();
            string selectWorkflowPrefix = $"flow{workflowPrefix}{StoragePrefixGenerator.Generate(sourceFlowID.ToLower())}";
            string currentWorkflowPrefix = $"flow{workflowPrefix}{StoragePrefixGenerator.Generate(targetFlowID.ToLower())}";


            MergeTable($"{selectWorkflowPrefix}runs", $"{currentWorkflowPrefix}runs", sourceFlowID, targetFlowID);
            MergeTable($"{selectWorkflowPrefix}flows", $"{currentWorkflowPrefix}flows", sourceFlowID, targetFlowID);
            MergeTable($"{selectWorkflowPrefix}histories", $"{currentWorkflowPrefix}histories", sourceFlowID, targetFlowID);

            List<string> actionAndVarTables = ListActionVarTables(selectWorkflowPrefix, startTime, endTime);

            foreach (string table in actionAndVarTables)
            {
                string targetTableName = table.Replace(selectWorkflowPrefix, currentWorkflowPrefix);

                MergeTable(table, targetTableName, sourceFlowID, targetFlowID);
            }
        }

        private static List<string> ListActionVarTables(string prefix, int startTime, int endTime)
        {
            TableServiceClient serviceClient = new TableServiceClient(AppSettings.ConnectionString);

            return serviceClient.Query().ToList()
                    .Where(s => s.Name.StartsWith(prefix) && (s.Name.EndsWith("actions") || s.Name.EndsWith("variables")) && int.Parse(s.Name.Substring(34, 8)) >= startTime && int.Parse(s.Name.Substring(34, 8)) <= endTime)
                    .Select(t => t.Name)
                    .ToList();
        }

        private static void MergeTable(string sourceTableName, string targetTableName, string sourceID, string targetID)
        {
            Console.WriteLine($"Merging {sourceTableName} to {targetTableName}");

            TableServiceClient serviceClient = new TableServiceClient(AppSettings.ConnectionString);
            Pageable<TableItem> sourceTableRecords = serviceClient.Query(filter: $"TableName eq '{sourceTableName}'");

            if (sourceTableRecords.Count() == 0)
            {
                Console.WriteLine($"Skip merge for {sourceTableName} due to not found.");

                return;
            }

            TableClient targetTableClient = new TableClient(AppSettings.ConnectionString, targetTableName);
            targetTableClient.CreateIfNotExists();

            TableClient sourceTableClient = new TableClient(AppSettings.ConnectionString, sourceTableName);

            //Split records into pages for memory usage consideration
            Pageable<TableEntity> entities = sourceTableClient.Query<TableEntity>(maxPerPage: 1000);

            int pageIndex = 0;

            foreach (Page<TableEntity> page in entities.AsPages())
            {
                Dictionary<string, List<TableTransactionAction>> actions = new Dictionary<string, List<TableTransactionAction>>();

                pageIndex++;

                if (page.Values.Count == 1000 || pageIndex != 1)
                {
                    Console.WriteLine($"Merging page {pageIndex} with {page.Values.Count} records.");
                }

                foreach (TableEntity te in page.Values)
                {
                    te["FlowId"] = targetID;
                    te.RowKey = te.RowKey.Replace(sourceID.ToUpper(), targetID.ToUpper());

                    string partitionKey = StoragePrefixGenerator.GeneratePartitionKey(te.RowKey);
                    te.PartitionKey = partitionKey;

                    if (!actions.ContainsKey(partitionKey))
                    {
                        actions.Add(partitionKey, new List<TableTransactionAction>());
                    }

                    actions[partitionKey].Add(new TableTransactionAction(TableTransactionActionType.UpsertReplace, te));

                    if (actions[partitionKey].Count == 100)
                    {
                        targetTableClient.SubmitTransaction(actions[partitionKey]);

                        actions.Remove(partitionKey);
                    }
                }

                foreach (List<TableTransactionAction> action in actions.Values)
                {
                    targetTableClient.SubmitTransaction(action);
                }
            }
        }

        public static void OverwriteFlowId(string sourceID, string targetID, string targetWorkflow)
        {
            string filter = $"FlowId eq '{sourceID}'";
            List<TableEntity> deletedWorkflowRecords = TableOperations.QueryMainTable(filter);

            TableClient tableClient = new TableClient(AppSettings.ConnectionString, TableOperations.DefinitionTableName);

            foreach (TableEntity te in deletedWorkflowRecords)
            {
                TableEntity updatedEntity = new TableEntity
                {
                    { "FlowId", targetID }
                };

                updatedEntity = te;
                updatedEntity["FlowId"] = targetID;
                updatedEntity["FlowName"] = targetWorkflow;
                updatedEntity.PartitionKey = te.PartitionKey;
                updatedEntity.RowKey = te.RowKey.Replace(sourceID.ToUpper(), targetID.ToUpper());

                tableClient.UpsertEntity<TableEntity>(updatedEntity);
            }
        }
    }
}
